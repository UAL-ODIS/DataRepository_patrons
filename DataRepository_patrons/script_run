from os import path
import pandas as pd

from datetime import date

import configparser
import argparse

from DataRepository_patrons import ldap_query
from DataRepository_patrons import grouper_query
from DataRepository_patrons import delta

co_filename = __file__
co_dir = path.dirname(co_filename)

if __name__ == '__main__':

    # Parse command-line arguments
    parser = argparse.ArgumentParser(description='Command-line driver for figshare patron management.')
    parser.add_argument('--config', required=True, help='path to configuration file')
    parser.add_argument('--ldap_host', help='LDAP host')
    parser.add_argument('--ldap_base_dn', help='base DN for LDAP bind and query')
    parser.add_argument('--ldap_user', help='user name for LDAP login')
    parser.add_argument('--ldap_password', help='password for LDAP login')
    parser.add_argument('--grouper_host', help='Grouper host')
    parser.add_argument('--grouper_base_path', help='base path for Grouper API')
    parser.add_argument('--grouper_user', help='user name for Grouper login')
    parser.add_argument('--grouper_password', help='password for Grouper login')
    parser.add_argument('--batch_size', help='synchronization batch size')
    parser.add_argument('--batch_timeout', help='synchronization batch timeout in seconds')
    parser.add_argument('--batch_delay', help='delay between batches in seconds')
    parser.add_argument('--portal', action='store_true', help='perform portal synchronization')
    parser.add_argument('--quota', action='store_true', help='perform quota synchronization')
    parser.add_argument('--sync', action='store_true', help='perform synchronization')
    parser.add_argument('--sync_max', help='maximum membership delta to allow when synchronizing')
    parser.add_argument('--debug', action='store_true', help='turn on debug logging')
    args = parser.parse_args()

    config = configparser.ConfigParser()
    config.read(args.config)

    cred_err = 0
    vargs = vars(args)
    for p in ['ldap_host', 'ldap_base_dn', 'ldap_user', 'ldap_password',
              'grouper_host', 'grouper_base_path', 'grouper_user', 'grouper_password',
              'batch_size', 'batch_timeout', 'batch_delay', 'portal', 'quota', 'sync_max']:

        if (p in vargs) and (vargs[p] is not None):
            vargs[p] = vargs[p]
        elif (p in config['global']) and (config['global'][p] is not None) and \
                (config['global'][p] != "***override***"):
            vargs[p] = config['global'][p]
        else:
            vargs[p] = '(unset)'

        if p in ['ldap_user', 'ldap_password', 'grouper_user', 'grouper_password']:
            if vargs[p] is '(unset)':
                print('    %s = (unset)', p)
                cred_err += 1
            else:
                print('    %s = (set)', p)
        else:
            print('    %s = %s', p, vargs[p])

    if cred_err:
        print("Not all credentials available!")
        print("Exiting")
        raise ValueError

    print('    sync = %s', args.sync)
    print('    debug = %s', args.debug)

    # Read in CSV file
    csv_url = config.get('global', 'csv_url')
    df = pd.read_csv(csv_url)

    unique_portals = df['Sub-portals'].unique()

    # Initiate LDAP connection
    ldc = ldap_query.LDAPConnection(ldap_host=vargs['ldap_host'],
                                    ldap_base_dn=vargs['ldap_base_dn'],
                                    ldap_user=vargs['ldap_user'],
                                    ldap_password=vargs['ldap_password'])

    # Loop over sub-portals
    if args.portal:
        for portal in unique_portals:
            print("Working on {} portal".format(portal))
            df_sub = df.loc[df['Sub-portals'] == portal]
            print(df_sub)

            # Get list of org codes for [portal]
            org_code_list = df_sub['Org Code']
            print("Org codes: {}".format(", ".join(org_code_list)))

            # LDAP query to retrieve members
            ldap_queries = ldap_query.ual_ldap_queries(org_code_list)

            ldap_members = ldap_query.ldap_search(ldc, ldap_queries)
            print(" EDS size {}".format(len(ldap_members)))

            # Grouper query
            grouper_portal = grouper_query.figshare_group(portal, 'portal')
            gq = grouper_query.GrouperQuery(grouper_host=vargs['grouper_host'],
                                            grouper_base_path=vargs['grouper_base_path'],
                                            grouper_user=vargs['grouper_user'],
                                            grouper_password=vargs['grouper_password'],
                                            grouper_group=grouper_portal)
            print(" Grouper size {}".format(len(gq.members)))

            d = delta.Delta(ldap_members=ldap_members,
                            grouper_query_instance=gq,
                            batch_size=int(vargs['batch_size']),
                            batch_timeout=int(vargs['batch_timeout']),
                            batch_delay=int(vargs['batch_delay']),
                            sync_max=int(vargs['sync_max']))

            print('ldap and grouper have {} members in common'.format(len(d.common)))
            print('synchronization will drop {} entries from grouper group'.format(len(d.drops)))
            print('synchronization will add {} entries to grouper group'.format(len(d.adds)))

            if args.sync:
                print('synchronizing ...')
                d.synchronize()
            else:
                print('dry run, not performing synchronization')

